#include <stdio.h>
#include <stdarg.h>
#include <stddef.h>
#include "eSipRteApi.hxx"
#include "eSipRteErr.hxx"
#include "eSipRteUtil.hxx"
#include "eSipRteLoad.hxx"


//#include "eSipServiceError.h"
#include "eSipRteDBMgr.hxx"
#include "IBCErrorDef.hxx"
#include "IBCErr2RteErr.hxx"
#include "rutil/ThreadIf.hxx"

//#include "amrtpproxy_load.h"

int ESipRteApiSendOption_t(SipRoute_t* _pstRte,SipNodeLocal_t* _pstLocal,SipNodeRemote_t* _pstRemote);
int ESipRteApiSendUpdate_t(SipRoute_t* _pstRte,SipNodeLocal_t* _pstLocal,SipNodeRemote_t* _pstRemote);
int SipRteApiNotifyChangeRouteStatus_t(int _nAvail,SipRoute_t* _pstRte,
                                    SipNodeLocal_t* _pstLocal,SipNodeRemote_t* _pstRemote,char* _pFailReason);
int ESipRteApiChangeLocalNode_t( int _nIsDelFlag, SipNodeLocal_t* _pstLocal);
void ESipRteApiPrintLog_t(int _nLevel,char*    _pMsg);
int ESipRteApiNotifyTrGWStatus_t(int _nAvail, TrGWRoute_t* _pstTrGW,char* _pFailReason);
void ESipRteApiChangeTimer_t( SipCoreTimer_t* pTimer, bool bTG);
int ESipRteApiNotifySystemResource_t(
   int               _nAlarmFlag,    //1:occured alarm, 0:alarm cleared
   int               _nResourceFlag, //0:CPU, 1:MEM
   int               _nCurUsage,     //Current Usage(%)
   int               _nLimitUsage,   //Limit Usage(%). set by mmi
   char*             _pReason);

char gszMainConf[1024][128];

void LoadFile();
void  AddLocal();
void  AddRemote();
void  AddRoute();
void  AddRSeq();
void  AddSSeq();
void  ModLocal();
void  ModRemote();
void  ModRoute();
void  ModRSeq();
void  ModSSeq();
void  ModRG() ;
void  AddRG() ;
void  ModTrGW();
void  AddTrGW();
void  AddReason();
void  ModReason();
void  ModEnv(bool bAdd=false);
void  ModTimer();
void  ModEmer();
ESipRteApiCallBack_t cb;

using namespace eSIP;

#include "eSipRteUsrMap.hxx"
typedef CUsrMap<int,void*,MapKeyBypass_t> YUN;

int ab[20];

int g_cnt=0;
////////
class CTestThread : public resip::ThreadIf
{
public:
   CTestThread(){
     resip::ThreadIf::run(); 
   }
   virtual ~CTestThread(){

   }
protected:
   virtual void thread(){
      while(1){
         if( g_cnt != 8 && g_cnt != 9 ){
            printf("THREAD READ ERROR!! %d\n",g_cnt);    
            fflush(stdout);
         }
         eSIP::CSipRteUtil::MilliSleep(1);
      }
   };
};

struct AAA{
   enum { e_maxnum_name=128 };
   int a;
};


void m_fnGetRealMemInfo2(int* total, int* free);
void m_fnGetMemInfo(int* total, int* free);

#include "eSipRteLoad.hxx"
int main( int argc, char* argv[])
{

   int total=0, free=0;
   int kkk=0;
   while(1){
      //eSIP::CSipRteUtil::MilliSleep(20);
      //m_fnGetRealMemInfo2(&total,&free);
      m_fnGetMemInfo(&total,&free);
      if( total > 0 ){
         printf("last free/total = %d/%d, %.2f%%\n",free,total,(float)free/(float)total); 
      }else{
         printf("last free/total = %d/%d\n",free,total);
      }
      sleep(5);
   }

#if 0 
   g_cnt=9;
   CTestThread kk[20];
   while(1){
      g_cnt=9;
      eSIP::CSipRteUtil::MilliSleep(1);
      g_cnt=8;
   }
#endif
   memset(&cb,0x00,sizeof(ESipRteApiCallBack_t));
   cb.m_pfuncESipRteApiSendOption=ESipRteApiSendOption_t;
   cb.m_pfuncESipRteApiSendUpdate=ESipRteApiSendUpdate_t;
   cb.m_pfuncESipRteApiNotifyChangeRouteStatus=SipRteApiNotifyChangeRouteStatus_t;
   cb.m_pfuncESipRteApiChangeLocalNode=ESipRteApiChangeLocalNode_t;
   cb.m_pfuncESipRteApiPrintLog=ESipRteApiPrintLog_t;
   cb.m_pfuncESipRteApiNotifyTrGWStatus=ESipRteApiNotifyTrGWStatus_t;
   cb.m_pfuncESipRteApiChangeTimer=ESipRteApiChangeTimer_t;
   cb.m_pfuncESipRteApiNotifySystemResource_t=ESipRteApiNotifySystemResource_t;


   int nRet=0;
   char szError[1024];szError[0]=0x00;
   char szError2[1024];szError2[0]=0x00;
   if( argc == 3 ){
      int nSystem=atoi(argv[1]);
      int nModule=atoi(argv[2]);
      printf("SYSTEM=%d, MODULE=%d \n",nSystem,nModule);
      nRet=IfESipRteApi_Init(&cb,E_ESipRteLogLevel_DEB,nSystem,nModule,0);
   }else{
      nRet=IfESipRteApi_Init(&cb,E_ESipRteLogLevel_DEB);
   }
   //nRet=IfESipRteApi_InitForOnlyDisplay(&cb);
   if( nRet != 0 ){
      printf("fail init:%s\n",GetStringSipRteErr(nRet,szError,sizeof(szError)));
      fflush(stdout);
      return 0;
   }

   LoadFile();

   GlobalOverLoadEnv_t env;
   env.m_fnMakeMod_Init();
   env.m_nMaxSES=2;

  THESIPDBMGR->m_fnPrint(9);
   GlobalOverLoadEnv_t env2;
   nRet=IfESipRteApi_ModEnv_LB(&env,&env2,NULL);
   printf("fail ---------------- %d: %s\n",nRet,GetStringSipRteErr(nRet,szError,sizeof(szError)));
  THESIPDBMGR->m_fnPrint(9);
   getc(stdin);
   while(1){

#if 0
      IfESipRteApi_SetSesCount(30);
      THESIPDBMGR->m_fnPrint(9);
      sleep (10);
   
      SipSpecialRouteSeq_t stValue;
      nRet=IfESipRteApi_FindSpecialRouteSeq(10011,&stValue);
      printf("RET:%d.........\n",nRet);
      THESIPDBMGR->m_fnPrint(5);
      exit(3);
   }
#endif

#if 0
      while(1){
         THESIPDBMGR->m_fnPrint(8);
         int nCPU=0;
         int nMaxCPU=0;
         int nMEM=0;
         int nMaxMEM=0;
         nRet=IfESipRteApi_IsNormalSysLoad(nCPU,nMaxCPU,nMEM,nMaxMEM);
         printf("RET:%d, CPU:%d,%d, MEM=%d,%d \n",nRet,nCPU,nMaxCPU,nMEM,nMaxMEM);
         nRet=IfESipRteApi_CheckMSGSize(4000);
         printf("MSG RET:%d \n",nRet);
         sleep(1);
      }

      THESIPDBMGR->m_fnPrint(3);
      sleep(1);
      THESIPDBMGR->m_fnPrintMap();
      printf("--------------------------------\n");
   }
   for( int i = 0 ; i < 13 ; i++){
      THESIPDBMGR->m_fnPrint(i);
   }
#endif
#if 0
   eSIP::CLoadCalculator<>* pCal=new eSIP::CLoadCalculator<>;
   eSIP::CLoadCalculator<>* pCal2=new eSIP::CLoadCalculator<>;
   eSIP::CLoadCalculator<>* pCal3=new eSIP::CLoadCalculator<>;
   int MAXCPS=2;
   unsigned int uiCPS;
   unsigned int uiInCPS;
   struct timeval curtime;
   bool bRet=false;
   int nCnt=0;
   while(1){
      eSIP::CSipRteUtil::MilliSleep(100);
      bRet=pCal->m_fnGetCalcLoad(1,uiCPS,MAXCPS,uiInCPS);
      gettimeofday(&curtime,NULL);
      if( bRet == true){
         printf("A OK   [%d.%06d] %d/%d\n",curtime.tv_sec,curtime.tv_usec,uiInCPS,MAXCPS);
      }else{
         printf("A Fail [%d.%06d] %d/%d\n",curtime.tv_sec,curtime.tv_usec,uiInCPS,MAXCPS);
      }

      bRet=pCal2->m_fnGetCalcLoad(1,uiCPS,MAXCPS,uiInCPS);
      gettimeofday(&curtime,NULL);
      if( bRet == true){ 
         printf("B OK   [%d.%06d] %d/%d\n",curtime.tv_sec,curtime.tv_usec,uiInCPS,MAXCPS);
      }else{
         printf("B Fail [%d.%06d] %d/%d\n",curtime.tv_sec,curtime.tv_usec,uiInCPS,MAXCPS);
      }

      bRet=pCal3->m_fnGetCalcLoad(1,uiCPS,MAXCPS,uiInCPS);
      gettimeofday(&curtime,NULL);
      if( bRet == true){
         printf("C OK   [%d.%06d] %d/%d\n",curtime.tv_sec,curtime.tv_usec,uiInCPS,MAXCPS);
      }else{
         printf("C Fail [%d.%06d] %d/%d\n",curtime.tv_sec,curtime.tv_usec,uiInCPS,MAXCPS);
      }
   }

   }
#endif
#if 0
   char szIP[128];memset(szIP,0x00,sizeof(szIP));
   IfESipRteApi_SetTrGWStatus(szIP,19701,szIP,0,true);
   IfESipRteApi_SetTrGWStatus(szIP,19702,szIP,0,true);
   THESIPDBMGR->m_fnPrint(6);

   TrGWRoute_t in;
   TrGWRoute_t out;
   in.m_fnMakeMod_Init();
   in.m_uiID=1;
   in.m_nStatus=TrGWRoute_t::E_TRGW_STATUS_AVAIL;
   IfESipRteApi_ModTrGW(&in,&out);

   in.m_fnMakeMod_Init();
   in.m_uiID=2;
   in.m_nStatus=TrGWRoute_t::E_TRGW_STATUS_AVAIL;
   IfESipRteApi_ModTrGW(&in,&out);



   in.m_fnMakeMod_Init();
   in.m_uiID=1;
   in.m_nStatus=TrGWRoute_t::E_TRGW_STATUS_MBLOCK;
   IfESipRteApi_ModTrGW(&in,&out);
 //  IfESipRteApi_SetTrGWStatus(szIP,19702,szIP,0,false);
   for( int i=0 ;i < 6 ; i++){
      TrGWRoute_t data;
      nRet=IfESipRteApi_DecisionTrGW(&data,szError);
      if( nRet != 0 ){
         GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
         printf("Error1: %s \n",szError);
         printf("Error2: %s \n",szError2);
      }else{
         printf("%d...%s\n",i,data.m_fnStr(szError2,sizeof(szError2)-1));
      }
   }
   in.m_fnMakeMod_Init();
   in.m_uiID=1;
   in.m_nStatus=TrGWRoute_t::E_TRGW_STATUS_AVAIL;
   IfESipRteApi_ModTrGW(&in,&out);
   in.m_fnMakeMod_Init();
   in.m_uiID=2;
   in.m_nStatus=TrGWRoute_t::E_TRGW_STATUS_MBLOCK;
   IfESipRteApi_ModTrGW(&in,&out);

   //IfESipRteApi_SetTrGWStatus(szIP,19701,szIP,0,false);
   //IfESipRteApi_SetTrGWStatus(szIP,19702,szIP,0,true);
   for( int i=0 ;i < 1 ; i++){
      TrGWRoute_t data;
      nRet=IfESipRteApi_DecisionTrGW(&data,szError);
      if( nRet != 0 ){
         GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
         printf("Error1: %s \n",szError);
         printf("Error2: %s \n",szError2);
      }else{
         printf("%d...%s\n",i,data.m_fnStr(szError2,sizeof(szError2)-1));
      }
   }
   THESIPDBMGR->m_fnPrint(6);
   in.m_fnMakeMod_Init();
   in.m_uiID=2;
   in.m_nStatus=TrGWRoute_t::E_TRGW_STATUS_AVAIL;
   IfESipRteApi_ModTrGW(&in,&out);
   in.m_fnMakeMod_Init();
   in.m_uiID=1;
   in.m_nStatus=TrGWRoute_t::E_TRGW_STATUS_MBLOCK;
   IfESipRteApi_ModTrGW(&in,&out);

   //IfESipRteApi_SetTrGWStatus(szIP,19701,szIP,0,false);
   //IfESipRteApi_SetTrGWStatus(szIP,19702,szIP,0,true);
   for( int i=0 ;i < 1 ; i++){
      TrGWRoute_t data;
      nRet=IfESipRteApi_DecisionTrGW(&data,szError);
      if( nRet != 0 ){
         GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
         printf("Error1: %s \n",szError);
         printf("Error2: %s \n",szError2);
      }else{
         printf("%d...%s\n",i,data.m_fnStr(szError2,sizeof(szError2)-1));
      }
   }
#endif
   //CTestThread thr;
#if 0
  THESIPDBMGR->m_fnPrint(5);

   SipSpecialRouteSeq_t srseq;
   SipSpecialRouteSeq_t srseq2;

   memset(&srseq,0x00,sizeof(srseq));
   srseq.m_uiID=2;
   sprintf(srseq.m_szDesc,"TEST_KKK");
#if 0
   for( int i=0; i < SipSpecialRouteSeq_t::E_MAX_RSEQ ; i++){
      srseq.m_fnMakeMod_Init();
      srseq.m_uiID=2;
      srseq.m_uiRSEQ[0]=0;
      nRet=IfESipRteApi_ModSpecialRouteSeq(&srseq,&srseq2,szError2);
      if( nRet != 0 ){
         printf("KK1: %s\n",GetStringSipRteErr(nRet,szError,sizeof(szError)));
         printf("KK2: %s\n",szError2);
         fflush(stdout);
      }else{
         char pBuf[2048]; 
         srseq2.m_fnStr(pBuf,2048); 
         printf("SUCCESS_%d: %s\n",i,pBuf);
      }
         
   }
#endif
#if 0
   for( int i=0; i < SipSpecialRouteSeq_t::E_MAX_RSEQ ; i++){
      srseq.m_uiRSEQ[i]=1000000+i+1;
      srseq.m_nRATE[i]=1;
   }

   nRet=IfESipRteApi_AddSpecialRouteSeq(&srseq,&srseq2,szError2);
   if( nRet != 0 ){
      printf("KK1: %s\n",GetStringSipRteErr(nRet,szError,sizeof(szError)));
      printf("KK2: %s\n",szError2);
      fflush(stdout);
   }
   IfESipRteApi_FindSpecialRouteSeq(2,&srseq);
   char pBuf[2048];
   srseq.m_fnStr(pBuf,2048); 
   printf("KK2: %s\n",pBuf);
#endif
#endif

#if 0
   SipRouteSeq_t rseq;
   SipRouteSeq_t rseq2;
   
   memset(&rseq,0x00,sizeof(rseq));
   
   for( int i=1; i < 400 ; i++){
      rseq.m_uiID = 1000000 + i;
      sprintf(rseq.m_szDesc,"TEST_%02d",i);
      if( i >= 301 ){
         rseq.m_uiDRTE = i%300;
      }else{
         rseq.m_uiDRTE = i;
      }
      nRet=IfESipRteApi_AddRouteSeq(&rseq,&rseq);
      if( nRet != 0 ){
         printf("KK1: %s\n",GetStringSipRteErr(nRet,szError,sizeof(szError)));
         printf("KK2_%d:%s\n",i,szError2);
         fflush(stdout);
         break;
      }
   }
#endif

#if 0
   SipNodeRemote_t rt;
   SipNodeRemote_t rt2;

   for( int i=1; i < 400 ; i++){
      memset(&rt,0x00,sizeof(rt));
      rt.m_uiID=i;
      sprintf(rt.m_szDesc,"TEST_RMT_%d",i);
      sprintf(rt.m_szDomain,"%d@sktims.net",i);
      rt.m_usIPver=4;
      rt.m_usPort=100+i;
      strcpy(rt.m_szIP,"10.10.10.10");
      rt.m_ucProto=E_ESIP_TRANSPORT_UDP;
      rt.m_sNATOn=0;
      nRet=IfESipRteApi_AddRemote(&rt,&rt2,szError2);
      if( nRet != 0 ){
         printf("KK1: %s\n",GetStringSipRteErr(nRet,szError,sizeof(szError)));
         printf("KK2:%s\n",szError2);
         fflush(stdout);
         break;
      }
   }
#endif
#if 0
   SipRoute_t route;
   SipRoute_t route2;

   route.m_fnMakeMod_Init();
   route.m_uiID=1;
   route.m_sOptAction=0;
   nRet=IfESipRteApi_ModRoute(&route,&route2,szError2);

   SipNodeLocal_t loc;
   SipNodeRemote_t rmt;

   loc.m_usIPver=4;
   loc.m_ucProto=E_ESIP_TRANSPORT_UDP;
   loc.m_usPort=5060;
   strcpy(loc.m_szIP,"223.33.173.38");


   rmt.m_usIPver=4;
   rmt.m_ucProto=E_ESIP_TRANSPORT_UDP;
   rmt.m_usPort=101;
   strcpy(rmt.m_szIP,"10.10.10.10");

   IfESipRteApi_RecvOption200OK(&loc,&rmt,true,0);
   THESIPDBMGR->m_fnPrint(3);
#endif
#if 0
   SipRoute_t route;
   SipRoute_t route2;
   for( int i=1; i < 400 ; i++){
      memset(&route,0x00,sizeof(route));
      route.m_uiID=i;
      sprintf(route.m_szDesc,"TEST_ROUTE_%d",i);
      route.m_uiLID=10001;
      if( i > 300 ){
         route.m_uiLID=20001;
      }
      route.m_uiRID=i;
      if( i > 300 ){
         route.m_uiRID=i-100;
      }
      route.m_uiTRTE=1;
      route.m_ucType=1;
      route.m_ucDoRouteMedia=1;
      route.m_sOptTime=5;
      route.m_sOptRetry=3;
      route.m_sOptAction=0;
      route.m_sSesRefreshTime=0; 
      route.m_nRouteGroup=1;
      route.m_nMAXCnt=10000;
      route.m_nDeactRsp=1;
      nRet=IfESipRteApi_AddRoute(&route,&route2,szError2);
      if( nRet != 0 ){
         printf("KK1: %s\n",GetStringSipRteErr(nRet,szError,sizeof(szError)));
         printf("KK2:%s\n",szError2);
         fflush(stdout);
         break;
      }
   }

   THESIPDBMGR->m_fnPrint(3);
#endif
#if 0
   while( 1 ){
   printf("\n\nALL DEACT \n");
   nRet=IfESipRteApi_Control_AllRoute(
   0, //ACT:1, DEACT:0 
   9, //GroupID
   false, //Enable group
   false,//include bypass
   szError2);

   if( nRet != 0 ){
      printf("KK1: %s\n",GetStringSipRteErr(nRet,szError,sizeof(szError)));
      printf("KK2:%s\n",szError2);
      fflush(stdout);
      return 0;
   }
   //THESIPDBMGR->m_fnPrint(3);

   sleep(5);
   printf("\n\nALL ACT \n");
   nRet=IfESipRteApi_Control_AllRoute(
   1, //ACT:1, DEACT:0 
   9, //GroupID
   false, //Enable group
   false,//include bypass
   szError2);

   if( nRet != 0 ){
      printf("KK1: %s\n",GetStringSipRteErr(nRet,szError,sizeof(szError)));
      printf("KK2:%s\n",szError2);
      fflush(stdout);
      return 0;
   }
   //THESIPDBMGR->m_fnPrint(3);
   sleep(2);
#endif
#if 0
   SipNodeLocal_t local;
   SipNodeRemote_t  remote;
   SipRoute_t   route;
   SipSpecialRouteSeq_t sreq;
   SipSpecialRouteSeq_t sreq_temp;
   
   for( int i= 0 ; ;i++ ){
      nRet=IfESipRteApi_DecisionTargetBySpecialRouteSeq(20001,&local,&remote,&route,szError2,false);
      if(nRet != 0 ){
         printf("\n%d: ERROR:%s\n",i+1,GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1));
      }else{
         printf("\n%d: SUCCESS %s \n",i+1,route.m_fnStr(szError2,sizeof(szError2)-1));
      }
      IfESipRteApi_FindSpecialRouteSeq(20001,&sreq);
#if 0
      if( i == 2 ) {
         sreq.m_nRATE[2]=2;
         IfESipRteApi_ModSpecialRouteSeq(&sreq,&sreq_temp);

      }
#endif
     
      printf("SRE: %s\n",sreq.m_fnStr(szError2,sizeof(szError2)-1));
      sleep(1);
   }
  }
#endif

#if 0
   //ModRoute();
   SipNodeLocal_t local;
   SipNodeRemote_t  remote;

   strcpy(local.m_szIP,"223.33.173.38");
   local.m_usPort=5060; 
   local.m_ucProto=E_ESIP_TRANSPORT_UDP; 

   strcpy(remote.m_szIP,"220.103.220.210");
   remote.m_usPort=5064; 
   remote.m_ucProto=E_ESIP_TRANSPORT_UDP; 

   int ncount=0;
   TrGWRoute_t trgw1; 
   TrGWRoute_t trgw2; 
   trgw1.m_fnMakeMod_Init();
   trgw1.m_uiID=1;
   trgw1.m_nStatus=TrGWRoute_t::E_TRGW_STATUS_MBLOCK;
   while(true){
      ncount++;
      //if( ncount%2 == 0 ){
         //nRet=IfESipRteApi_SetTrGWStatus("0.0.0.0",19701,NULL,0,true);
        // trgw1.m_nStatus=TrGWRoute_t::E_TRGW_STATUS_MBLOCK;
        // IfESipRteApi_ModTrGW(&trgw1,&trgw2);
      //}else
      {
         printf("-->CHAGNE CON TRUE \n",nRet);
         nRet=IfESipRteApi_SetTrGWStatus("0.0.0.0",19701,NULL,0,true);
         trgw1.m_nStatus=TrGWRoute_t::E_TRGW_STATUS_MBLOCK;
         printf("-->CHAGNE BLK \n",nRet);
         IfESipRteApi_ModTrGW(&trgw1,&trgw2);
         printf("-->CHAGNE CON FALSE \n",nRet);
         nRet=IfESipRteApi_SetTrGWStatus("0.0.0.0",19701,NULL,0,false);

         printf("-->CHAGNE UBLK \n",nRet);
         trgw1.m_nStatus=0;
         IfESipRteApi_ModTrGW(&trgw1,&trgw2);
      }
#if 0
      if( ncount%3 == 0 ){
         trgw1.m_nStatus=0;
         IfESipRteApi_ModTrGW(&trgw1,&trgw2);
      }
#endif
      printf("nRet=%d \n",nRet);
      sleep(2);

   }
#endif
   
#if 1
   SipNodeLocal_t local;
   SipNodeRemote_t  remote;
   SipRoute_t       stRoute;
   for( int i= 0 ; ;i++ ){
      nRet=IfESipRteApi_DecisionTargetBySpecialRouteSeq(20001,&local,&remote,
                           &stRoute,szError2,false);
      if(nRet != 0 ){
         printf("E -> %s(%d)\n",GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1),i+1);
      }else{
         printf("S -> Route: %d.\n",stRoute.m_uiID);
      }
      sleep(1);

      //THESIPDBMGR->m_fnPrint(5);
      
   }
   }
#endif

#if 0
   int nCnt=0;
   SipCoreTrace_t* pstTrace[SipTraceDataBase_t::E_MAXNUM];
   char szCall[1024];
   while(1){
      memset(szCall,0x00,sizeof(szCall));
      scanf("%s",szCall);
      bool bRet=IfESipRteApi_CheckTrace("",szCall,0,nCnt,pstTrace);
      if( bRet == true){
         for( int i=0 ;i < nCnt; i++){
            printf("Trace:%s\n",pstTrace[i]->m_fnStr(szError,sizeof(szError)-1));
         }
      }else{
         printf("no trace!!\n");
      }
   }
  
   //ModEnv();
   //THESIPDBMGR->m_fnPrint(8);
   while(1)
   {
      sleep(10);
   }

   ModEmer();

   while(1)
   {
      sleep(10);
   }

#endif
  
#if 0 
   printf("AAAAAAAAAAAAA\n");
   THESIPDBMGR->m_fnPrint(2);
   //THESIPDBMGR->m_fnPrint(CSipRteData::E_SIPRTE_RTE);
   SipNodeLocal_t  stLocal;
   SipNodeRemote_t stRmt;
   SipRoute_t      stRoute;
   SipRouteGroup_t stGroup;
   GlobalOverLoadEnv_t stEnv;
   

   strcpy(stLocal.m_szIP,"121.134.202.25");
   stLocal.m_usPort=5060; 
   stLocal.m_ucProto=E_ESIP_TRANSPORT_UDP; 

   strcpy(stRmt.m_szIP,"50.1.10.194");
   stRmt.m_usPort=5064; 
   stRmt.m_ucProto=E_ESIP_TRANSPORT_UDP; 

   int nLoad=0;
   int nMaxLoad=0;
   int nLoad2=0;
   int nMaxLoad2=0;
   int nMaxLoad3=0;

   bool bAudio=true;
   //int nCnt=-1;

   char* szMIN=NULL;
   int nSCPS=0;
   int nMSec=0;
   int nCnt=0;
   THESIPDBMGR->m_fnPrint(9);

   struct timeval curtime;
   struct timeval curtime2;
   const char* szCallType="A";
   eSIP::CLoadCalculator<>* pCal=new eSIP::CLoadCalculator<>;
   IfESipRteApi_GetRouteByTransport(&stLocal,&stRmt,&stRoute,false,szError);
   while(1)
{
#if 0
   if (  nCnt%2 == 0){
       szMIN=NULL;
       bAudio=true;
       szCallType="A";
   }else if(  nCnt%2 == 1 ){
       szMIN=NULL;
       bAudio=false;
       szCallType="V";
   }
    szMIN="110";
    bAudio=true;
    szCallType="A";
#endif
#if 0
      if( nCnt%3 == 0 ){ 
         szMIN="119";
          bAudio=true;
          szCallType="E";
       //  eSIP::CSipRteUtil::MilliSleep(10);
      }else if (  nCnt%3 == 1){
          szMIN=NULL;
          bAudio=true;
          szCallType="A";
      }else if(  nCnt%3 == 2 ){
          szMIN=NULL;
          bAudio=false;
          szCallType="V";
      //   eSIP::CSipRteUtil::MilliSleep(10);
      }
      eSIP::CSipRteUtil::MilliSleep(100);
#endif;
#if 1
      bAudio=true;
      if( nCnt%3 == 0 ){ 
          szCallType="E";
          szMIN="119";
          bAudio = true;
      }else if (  nCnt%3 == 1){
          szMIN=NULL;
          szCallType="A";
          bAudio = true;
      }else if(  nCnt%3 == 2 ){
          szMIN=NULL;
          szCallType="V";
          bAudio = false;
      }

      eSIP::CSipRteUtil::MilliSleep(40);

#endif
      nCnt++;
      gettimeofday(&curtime,NULL); 
      char szError3[128];

#if 0
      //printf("INPUT [%d], %s\n",curtime.tv_sec,szCallType);
      unsigned int uiCPS=0;
      unsigned int uiInCPS=0;
      int nMAXCPS=20;
      bool bRet = 0;
      bRet=pCal->m_fnGetCalcLoad(1,uiCPS,nMAXCPS,uiInCPS);
      if( bRet == true){ 
         printf("B OK   [%d.%06d] %d/%d/%d\n",curtime.tv_sec,curtime.tv_usec,uiCPS,nMAXCPS,uiInCPS);
      }else{
         printf("B Fail [%d.%06d] %d/%d/%d\n",curtime.tv_sec,curtime.tv_usec,uiCPS,nMAXCPS,uiInCPS);
      }
#endif
#if 1
      nRet=IfESipRteApi_RecvInitMsgByTransport(&stLocal,&stRmt,&stRoute,nLoad,nMaxLoad,
            false,true,szMIN,bAudio,szError3);
      gettimeofday(&curtime2,NULL); 
      if( curtime2.tv_sec - curtime.tv_sec > 0 ){
         printf("INPUT [%d] - [%d], %s\n",curtime.tv_sec,curtime2.tv_sec,szCallType);
      }
      if( nRet != 0 ){
         GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
         int nCauseCode=0;
         int nRspCode=0;
         int nret=IfESipRteApi_GetReasonByRouteID(stRoute.m_uiID,
                  SipReasonCode_t::E_CPS_OVERLOAD_CAUSE,nCauseCode,nRspCode,szError);
         IfESipRteApi_FindEnv_LB(&stEnv);
         SLOG(E_ESipRteLogLevel_ERR,"%03d [%d.%06d]<<<- %s, %s, %s",
               nCnt%25,curtime.tv_sec,curtime.tv_usec,szError2,szError3,szCallType);
      }else{
         IfESipRteApi_GetRouteByTransport(&stLocal,&stRmt,&stRoute,false,szError);
         IfESipRteApi_FindRouteGroup(stRoute.m_nRouteGroup,&stGroup);
         IfESipRteApi_FindEnv_LB(&stEnv);
         SLOG(E_ESipRteLogLevel_INF,"%03d [%d.%06d] ID=%d/%d, BUSY/IC:%d/%d R_CPS:%d/%d, G_CPS:%d/%d E/A/V=%d/%d/%d, %s",
                  nCnt%25,
                  curtime.tv_sec,curtime.tv_usec,
                  stRoute.m_uiID, stGroup.m_uiID,
                  stRoute.m_uiBusyCnt,stRoute.m_uiICCnt, 
                  stGroup.m_nCurCPS,stGroup.m_nMaxCPS_LB,
                  stEnv.m_nCurCPS,stEnv.m_nMaxCPS,
                  stEnv.m_nMinCPS_Emer,stEnv.m_nMaxCPS_Audio,stEnv.m_nMaxCPS_Video,szCallType);
                 
         IfESipRteApi_DeCrease1RouteCount(stRoute.m_uiID,true); 
         fflush(stdout);
      }
#endif
}
#endif
//} //end while(1)
   sleep (1);
   return 0;
}

static int i_cnt=0;
int ESipRteApiNotifySystemResource_t(
   int               _nAlarmFlag,    //1:occured alarm, 0:alarm cleared
   int               _nResourceFlag, //0:CPU, 1:MEM
   int               _nCurUsage,     //Current Usage(%)
   int               _nLimitUsage,   //Limit Usage(%). set by mmi
   char*             _pReason)
{

   printf("ALAMR FLAG(%u:%s) R_FLAG(%u:%s) (%u%%/%u%%), %s\n",
   _nAlarmFlag,_nAlarmFlag==0?"CLREAD":"OCCURED",
   _nResourceFlag,_nResourceFlag==0?"CPU":"MEM",
   _nCurUsage,_nLimitUsage,_pReason);
 
   GlobalOverLoadEnv_t env; 
   GlobalOverLoadEnv_t env2; 
   env.m_fnMakeMod_Init();
   if( _nAlarmFlag == 1 ){ 
      env.m_nMaxMEM=90;      
      env.m_nMaxCPU=90;      
      //IfESipRteApi_ModEnv(&env,&env2);
   }else{
      env.m_nMaxMEM=1;      
      env.m_nMaxCPU=1;      
      //IfESipRteApi_ModEnv(&env,&env2);
   }


   return 0;
}

void ESipRteApiChangeTimer_t( SipCoreTimer_t* pTimer,bool bTG){
   char szBuf[256];
   printf("ChangeTimer: %s, bool:%d\n",pTimer->m_fnStr(szBuf,sizeof(szBuf)),bTG);
}
int ESipRteApiNotifyTrGWStatus_t(int _nAvail, TrGWRoute_t* _pstTrGW,char* pReason) 
{
   //char* pReason=(char*)"aa";

   printf("ChangeTrGW: %s id=%u, %s\n",_nAvail == 0 ? "UNVAIL":"AVAIL",_pstTrGW->m_uiID,pReason);
   return 0;
}

int ESipRteApiChangeLocalNode_t( int _nIsDelFlag, SipNodeLocal_t* _pstLocal)
{
   printf("ChangeLocalNode: %s id=%u\n",_nIsDelFlag == 0 ? "ADD":"DEL",_pstLocal->m_uiID);
   return 0;
}
void  ModTimer() 
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipCoreTimer_t stValue;
   SipCoreTimer_t stOutValue;
   memset(&stValue,0x00,sizeof(stValue));
   //stValue.m_fnMakeMod_Init();

   stValue.m_nTimeT2=atoi(gszMainConf[0]);
   stValue.m_nTimeTA=atoi(gszMainConf[1]);
   stValue.m_nTimeTB=atoi(gszMainConf[2]);
   stValue.m_nTimeTC=atoi(gszMainConf[3]);
   stValue.m_nTimeTD=atoi(gszMainConf[4]);
   stValue.m_nTimeTE=atoi(gszMainConf[5]);
   stValue.m_nTimeTF=atoi(gszMainConf[6]);
   stValue.m_nTimeTG=atoi(gszMainConf[7]);
   stValue.m_nTimeTH=atoi(gszMainConf[8]);
   stValue.m_nTimeTI=atoi(gszMainConf[9]);
   stValue.m_nTimeTJ=atoi(gszMainConf[10]);
   stValue.m_nTimeTK=atoi(gszMainConf[11]);
   stValue.m_nTimeTL=atoi(gszMainConf[12]);
   stValue.m_nTimeTM=atoi(gszMainConf[13]);
   stValue.m_nTimeDAlive=atoi(gszMainConf[14]);
   stValue.m_nTimeDTerm=atoi(gszMainConf[15]);
   stValue.m_nTimeTrGW=atoi(gszMainConf[16]);

   int nRet=0;
   nRet=IfESipRteApi_ModTimer(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  ModEnv(bool bAdd) 
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   GlobalOverLoadEnv_t stValue;
   GlobalOverLoadEnv_t stOutValue;
   memset(&stValue,0x00,sizeof(stValue));
   //stValue.m_fnMakeMod_Init();

   stValue.m_nMaxSES=atoi(gszMainConf[0]);
   stValue.m_nChkSES=atoi(gszMainConf[1]);
   stValue.m_nMaxMSG=atoi(gszMainConf[2]);
   stValue.m_nChkMSG=atoi(gszMainConf[3]);
   stValue.m_nMaxCPS=atoi(gszMainConf[4]);
   stValue.m_nChkCPS=atoi(gszMainConf[5]);
   stValue.m_nMaxCPU=atoi(gszMainConf[6]);
   stValue.m_nChkCPU=atoi(gszMainConf[7]);
   stValue.m_nMaxMEM=atoi(gszMainConf[8]);
   stValue.m_nChkMEM=atoi(gszMainConf[9]);
   stValue.m_nMaxTPS=atoi(gszMainConf[10]);
   stValue.m_nChkTPS=atoi(gszMainConf[11]);
   stValue.m_nMinCPS_Emer=atoi(gszMainConf[12]); //m_nMinCPS_Emer
   stValue.m_nMaxCPS_Audio=atoi(gszMainConf[13]); //m_nMaxCPS_Audio
   stValue.m_nMaxCPS_Video=atoi(gszMainConf[14]); //m_nMaxCPS_Video
   stValue.m_nChkCPSClass=atoi(gszMainConf[15]); //m_nChkCPSClass

   int nRet=0;
   nRet=IfESipRteApi_ModEnv(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  AddReason() 
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipReasonCode_t stValue;
   SipReasonCode_t stOutValue;
   memset(&stValue,0x00,sizeof(stValue));
   //stValue.m_fnMakeMod_Init();

   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   int nCnt=1;
   for( int i = 0 ; i < SipReasonCode_t::E_CAUSE_MAX ; i++){
      stValue.m_nCauseCode[i]=atoi(gszMainConf[++nCnt]);
      stValue.m_nRspCode[i]=atoi(gszMainConf[++nCnt]);
      strncpy(stValue.m_szCause[i],gszMainConf[++nCnt],sizeof(stValue.m_szCause[i]));
      ++nCnt;
   }

   int nRet=0;
   nRet=IfESipRteApi_AddReason(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  ModReason() 
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipReasonCode_t stValue;
   SipReasonCode_t stOutValue;
   memset(&stValue,0x00,sizeof(stValue));
   //stValue.m_fnMakeMod_Init();

   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   int nCnt=1;
   for( int i = 0 ; i < SipReasonCode_t::E_CAUSE_MAX ; i++){
      stValue.m_nCauseCode[i]=atoi(gszMainConf[++nCnt]);
      stValue.m_nRspCode[i]=atoi(gszMainConf[++nCnt]);
      strncpy(stValue.m_szCause[i],gszMainConf[++nCnt],sizeof(stValue.m_szCause[i]));
   }

   int nRet=0;
   nRet=IfESipRteApi_ModReason(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  AddTrGW() 
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   TrGWRoute_t stValue;
   TrGWRoute_t stOutValue;
   memset(&stValue,0x00,sizeof(stValue));
   //stValue.m_fnMakeMod_Init();

   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   strcpy(stValue.m_szSvrIP,gszMainConf[2]);
   strcpy(stValue.m_szTrGWIP,gszMainConf[3]);

   stValue.m_usSvrPort = atoi(gszMainConf[4]);
   stValue.m_usTrGWPort = atoi(gszMainConf[5]);
   stValue.m_nCallRate = atoi(gszMainConf[6]);
   stValue.m_nMaxCount = atoi(gszMainConf[7]);
   stValue.m_nStatus = atoi(gszMainConf[8]);

   int nRet=0;
   nRet=IfESipRteApi_AddTrGW(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}

void  ModTrGW() 
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   TrGWRoute_t stValue;
   TrGWRoute_t stOutValue;
   memset(&stValue,0x00,sizeof(stValue));
   //stValue.m_fnMakeMod_Init();

   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   strcpy(stValue.m_szSvrIP,gszMainConf[2]);
   strcpy(stValue.m_szTrGWIP,gszMainConf[3]);

   stValue.m_usSvrPort = atoi(gszMainConf[4]);
   stValue.m_usTrGWPort = atoi(gszMainConf[5]);
   stValue.m_nCallRate = atoi(gszMainConf[6]);
   stValue.m_nMaxCount = atoi(gszMainConf[7]);
   stValue.m_nStatus = atoi(gszMainConf[8]);

   int nRet=0;
   nRet=IfESipRteApi_ModTrGW(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}

void  ModSSeq()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipSpecialRouteSeq_t stValue;
   SipSpecialRouteSeq_t stOutValue;
   memset(&stValue,0x00,sizeof(SipSpecialRouteSeq_t));


   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);

   int k=2;
   for( int i=0 ; i < SipSpecialRouteSeq_t::E_MAX_RSEQ ; i ++){
      if( gszMainConf[k][0]==0x00 ){
         break;
      }
      stValue.m_uiRSEQ[i]=atoi(gszMainConf[k++]);
      stValue.m_nRATE[i]=atoi(gszMainConf[k++]);
   }

   int nRet=0;
   nRet=IfESipRteApi_ModSpecialRouteSeq(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  AddSSeq()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipSpecialRouteSeq_t stValue;
   SipSpecialRouteSeq_t stOutValue;
   memset(&stValue,0x00,sizeof(stValue));

   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);

   int k=2;
   for( int i=0 ; i < SipSpecialRouteSeq_t::E_MAX_RSEQ ; i ++){
      if( gszMainConf[k][0]==0x00 ){
         break;
      }
      stValue.m_uiRSEQ[i]=atoi(gszMainConf[k++]);
      stValue.m_nRATE[i]=atoi(gszMainConf[k++]);
   }

   int nRet=0;
   nRet=IfESipRteApi_AddSpecialRouteSeq(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  AddRG() 
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipRouteGroup_t stValue;
   SipRouteGroup_t stOutValue;
   memset(&stValue,0x00,sizeof(stValue));
   //stValue.m_fnMakeMod_Init();

   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   stValue.m_nMaxCPS = atoi(gszMainConf[2]);
   stValue.m_nCtrlCPSOn = atoi(gszMainConf[3]);
   stValue.m_nMaxTPS = atoi(gszMainConf[4]);
   stValue.m_nCtrlTPSOn = atoi(gszMainConf[5]);
   stValue.m_nRspID = atoi(gszMainConf[6]);
   stValue.m_nChargingOn = atoi(gszMainConf[7]);
   stValue.m_nChargingCode = atoi(gszMainConf[8]);
   stValue.m_nChargingIDC = atoi(gszMainConf[9]);
   stValue.m_nRoamingIDC = atoi(gszMainConf[10]);


   int nRet=0;
   for( int i=0; i < 40 ; i++){
   nRet=IfESipRteApi_AddRouteGroup(&stValue,&stOutValue,szError);
   stValue.m_uiID++;
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   }
   fflush(stdout);
}
void  ModRG() 
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipRouteGroup_t stValue;
   SipRouteGroup_t stOutValue;
   stValue.m_fnMakeMod_Init();

   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   stValue.m_nMaxCPS = atoi(gszMainConf[2]);
   stValue.m_nCtrlCPSOn = atoi(gszMainConf[3]);
   stValue.m_nMaxTPS = atoi(gszMainConf[4]);
   stValue.m_nCtrlTPSOn = atoi(gszMainConf[5]);
   stValue.m_nRspID = atoi(gszMainConf[6]);
   stValue.m_nChargingOn = atoi(gszMainConf[7]);
   stValue.m_nChargingCode = atoi(gszMainConf[8]);
   stValue.m_nChargingIDC = atoi(gszMainConf[9]);
   stValue.m_nRoamingIDC = atoi(gszMainConf[10]);

   int nRet=0;
   printf("Before, %s \n",stValue.m_fnStr(szError2,sizeof(szError2)));
   nRet=IfESipRteApi_ModRouteGroup(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}

void  ModRSeq()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipRouteSeq_t stValue;
   SipRouteSeq_t stOutValue;
   memset(&stValue,0x00,sizeof(SipRouteSeq_t));


   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);

   stValue.m_uiDRTE=atoi(gszMainConf[2]);
   for( int i=0 ; i < SipRouteSeq_t::E_MAX_ARTE ; i ++){
      if( gszMainConf[3+i][0]==0x00 ){
         break;
      }
      stValue.m_uiARTE[i]=atoi(gszMainConf[3+i]);
   }
   int nRet=0;
   nRet=IfESipRteApi_ModRouteSeq(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  AddRSeq()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipRouteSeq_t stValue;
   SipRouteSeq_t stOutValue;
   memset(&stValue,0x00,sizeof(SipRouteSeq_t));


   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);

   stValue.m_uiDRTE=atoi(gszMainConf[2]);
   for( int i=0 ; i < SipRouteSeq_t::E_MAX_ARTE ; i ++){
      if( gszMainConf[3+i][0]==0x00 ){
         break;
      }
      stValue.m_uiARTE[i]=atoi(gszMainConf[3+i]);
   }
#if 0
   for( int i=0 ; i < 4 ; i ++){
      stValue.m_uiRSEQ[i]=atoi(gszMainConf[2+i]);
      stValue.m_uiRATE[i]=atoi(gszMainConf[3+i]);
   }
#endif

   int nRet=0;
   nRet=IfESipRteApi_AddRouteSeq(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  AddRoute()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipRoute_t stValue;
   SipRoute_t stOutValue;
   memset(&stValue,0x00,sizeof(SipRoute_t));


   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   stValue.m_uiLID=atoi(gszMainConf[2]);
   stValue.m_uiRID=atoi(gszMainConf[3]);
   stValue.m_uiTRTE=atoi(gszMainConf[4]);
   stValue.m_ucType=atoi(gszMainConf[5]);
   stValue.m_ucDoRouteMedia=atoi(gszMainConf[6]);
   stValue.m_sOptTime=atoi(gszMainConf[7]);
   stValue.m_sOptRetry=atoi(gszMainConf[8]);
   stValue.m_sOptAction=atoi(gszMainConf[9]);
   stValue.m_sSesRefreshTime=atoi(gszMainConf[10]);



   int nRet=0;
   nRet=IfESipRteApi_AddRoute(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  ModRoute()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipRoute_t stValue;
   SipRoute_t stOutValue;
   //memset(&stValue,0x00,sizeof(stValue));
   stValue.m_fnMakeMod_Init();

   stValue.m_uiID = atoi(gszMainConf[0]);
   stValue.m_sOptAction=atoi(gszMainConf[1]);
#if 0
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   stValue.m_uiLID=atoi(gszMainConf[2]);
   stValue.m_uiRID=atoi(gszMainConf[3]);
   stValue.m_uiTRTE=atoi(gszMainConf[4]);
   stValue.m_ucType=atoi(gszMainConf[5]);
   stValue.m_ucDoRouteMedia=atoi(gszMainConf[6]);
   stValue.m_sOptTime=atoi(gszMainConf[7]);
   stValue.m_sOptRetry=atoi(gszMainConf[8]);
   stValue.m_sOptAction=atoi(gszMainConf[9]);
   //stValue.m_sSesRefreshTime=atoi(gszMainConf[10]);
   //stValue.m_nRouteGroup=atoi(gszMainConf[11]);
   //stValue.m_nMAXCnt=atoi(gszMainConf[12]);
   //stValue.m_nDeactRsp=atoi(gszMainConf[13]);
#endif



   int nRet=0;
   printf("\nBefore: %s \n",stValue.m_fnStr(szError2,sizeof(szError2)));
   nRet=IfESipRteApi_ModRoute(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}

void  AddRemote()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipNodeRemote_t stValue;
   SipNodeRemote_t stOutValue;
   memset(&stValue,0x00,sizeof(SipNodeRemote_t));


   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   strcpy(stValue.m_szDomain,gszMainConf[2]);
   stValue.m_usIPver=atoi(gszMainConf[3]);
   stValue.m_usPort=atoi(gszMainConf[4]);
   strcpy(stValue.m_szIP,gszMainConf[5]);
   stValue.m_ucProto=atoi(gszMainConf[6]);



   int nRet=0;
   nRet=IfESipRteApi_AddRemote(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  ModEmer()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   EmergencyCall_t stValue;
   EmergencyCall_t stOutValue;
   memset(&stValue,0x00,sizeof(EmergencyCall_t));


   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   strcpy(stValue.m_szMIN,gszMainConf[2]);

   int nRet=0;
   printf("Before: %s \n",stValue.m_fnStr(szError2,sizeof(szError2)));
   nRet=IfESipRteApi_ModEmer(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  ModRemote()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipNodeRemote_t stValue;
   SipNodeRemote_t stOutValue;
   memset(&stValue,0x00,sizeof(SipNodeLocal_t));


   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   strcpy(stValue.m_szDomain,gszMainConf[2]);
   stValue.m_usIPver=atoi(gszMainConf[3]);
   stValue.m_usPort=atoi(gszMainConf[4]);
   strcpy(stValue.m_szIP,gszMainConf[5]);
   stValue.m_ucProto=atoi(gszMainConf[6]);

#if 0
   stValue.m_usIPver=0;
   stValue.m_usPort=0;
   stValue.m_szIP[0]=0x00;
   stValue.m_ucProto=0;
#endif

   int nRet=0;
   printf("Before: %s \n",stValue.m_fnStr(szError2,sizeof(szError2)));
   nRet=IfESipRteApi_ModRemote(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}
void  ModLocal()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipNodeLocal_t stValue;
   SipNodeLocal_t stOutValue;
   memset(&stValue,0x00,sizeof(SipNodeLocal_t));
   stValue.m_fnMakeMod_Init();


   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   strcpy(stValue.m_szDomain,gszMainConf[2]);
   stValue.m_usIPver=atoi(gszMainConf[3]);
   stValue.m_usPort=atoi(gszMainConf[4]);
   strcpy(stValue.m_szIP,gszMainConf[5]);
   stValue.m_ucProto=atoi(gszMainConf[6]);
   stValue.m_cRCSOn=atoi(gszMainConf[7]);

#if 0
   stValue.m_usIPver=0;
   stValue.m_usPort=0;
   stValue.m_szIP[0]=0x00;
   stValue.m_ucProto=0;
#endif

   int nRet=0;
   printf("Before: %s \n",stValue.m_fnStr(szError2,sizeof(szError2)));
   nRet=IfESipRteApi_ModLocal(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      SLOG(E_ESipRteLogLevel_ERR,"<<<- %s \n",szError);
   }else{
      SLOG(E_ESipRteLogLevel_ERR,"success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}


void  AddLocal()
{
   char szError[256];szError[0]=0x00;
   char szError2[256];szError2[0]=0x00;
   SipNodeLocal_t stValue;
   SipNodeLocal_t stOutValue;
   memset(&stValue,0x00,sizeof(SipNodeLocal_t));


   stValue.m_uiID = atoi(gszMainConf[0]);
   strcpy(stValue.m_szDesc,gszMainConf[1]);
   strcpy(stValue.m_szDomain,gszMainConf[2]);
   stValue.m_usIPver=atoi(gszMainConf[3]);
   stValue.m_usPort=atoi(gszMainConf[4]);
   strcpy(stValue.m_szIP,gszMainConf[5]);
   stValue.m_ucProto=atoi(gszMainConf[6]);
   stValue.m_cRCSOn=atoi(gszMainConf[7]);

   printf("IN, %s \n",stValue.m_fnStr(szError2,sizeof(szError2)));


   int nRet=0;
   nRet=IfESipRteApi_AddLocal(&stValue,&stOutValue,szError);
   if( nRet != 0 ){
      GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
      printf("Error1: %s \n",szError);
      printf("Error2: %s \n",szError2);
   }else{
      printf("success, %s \n",stOutValue.m_fnStr(szError2,sizeof(szError2)));
   }
   fflush(stdout);
}

int ESipRteApiSendOption_t(SipRoute_t* _pstRte,SipNodeLocal_t* _pstLocal,SipNodeRemote_t* _pstRemote)
{
  return 0;
  SLOG(E_ESipRteLogLevel_INF,"SendOption: id=%u, lid=%u, rid=%u",
         _pstRte->m_uiID,_pstLocal->m_uiID,_pstRemote->m_uiID);
   fflush(stdout);
   return 0;
}
int ESipRteApiSendUpdate_t(SipRoute_t* _pstRte,SipNodeLocal_t* _pstLocal,SipNodeRemote_t* _pstRemote)
{
   printf("SendUpdate: rid=%u, lid=%u, rid=%u\n",
         _pstRte->m_uiID,_pstLocal->m_uiID,_pstRemote->m_uiID);
   fflush(stdout);
   return 0;
}
int SipRteApiNotifyChangeRouteStatus_t(int _nAvail,SipRoute_t* _pstRte,
                                    SipNodeLocal_t* _pstLocal,SipNodeRemote_t* _pstRemote,char* pReason)
{
   //char* pReason=(char*)"aa";
#if 0
   printf("===>Notify: %s, id=%u, lid=%u, rid=%u, %s\n",
         _nAvail==1?"OK":"NG",_pstRte->m_uiID,_pstLocal->m_uiID,_pstRemote->m_uiID,pReason);
#else
   SLOG(E_ESipRteLogLevel_INF,"Notify: %s, id=%u, lid=%u, rid=%u, %s",
         _nAvail==1?"OK":"NG",_pstRte->m_uiID,_pstLocal->m_uiID,_pstRemote->m_uiID,pReason);
#endif
   fflush(stdout);
   return 0;
}
void ESipRteApiPrintLog_t(int _nLevel,char*    _pMsg)
{
   printf("%s\n",_pMsg);
   fflush(stdout);
}

void LoadFile()
{
   FILE* fp=NULL;
   fp=fopen("cfg.cmd","r");
   if(fp==NULL) return;

   char linebuf[1024];
   int nCnt=0;
   while(fgets(linebuf,1024, fp) != NULL){
      if( linebuf[0]==0x00 || linebuf[0]=='#' ){
         continue;
      }
      eSIP::CSipRteUtil::m_fnLRTrim(linebuf);
      if( linebuf[0]==0x00 ) continue;
      strcpy(gszMainConf[nCnt],linebuf);
      nCnt++;
   }
   fclose(fp);
}

int SetDSCP(int* pSockFD, unsigned int _uiDSCP)
{
   int nRet=0;
   if( pSockFD==NULL || *pSockFD < 0 || _uiDSCP <= 0 ) return 0;

   _uiDSCP = _uiDSCP <<2 ;

   nRet=setsockopt( *pSockFD, IPPROTO_IP, IP_TOS, 
         (const void *)&_uiDSCP, sizeof(_uiDSCP));
   if(nRet<0){
      return 1;//fail
   }
   return 0;    
}




#if 0
   //IfESipRteApi_SetTrGWStatus("0.0.0.0",8880,"124.0.24.111",0,true);
   for( int i=0 ;i < 5 ; i++){
      TrGWRoute_t data;
      nRet=IfESipRteApi_DecisionTrGW(&data,szError);
      if( nRet != 0 ){
         GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
         printf("Error1: %s \n",szError);
         printf("Error2: %s \n",szError2);
      }else{
         printf("%d...%s\n",i,data.m_fnStr(szError2,sizeof(szError2)-1));
      }
   }
   THESIPDBMGR->m_fnPrint(6);
   fflush(stdout);
   AddRG();
   SipRouteGroupDataBase_t data;
   IfESipRteApi_GetAllRouteGroup(&data);
   for( int i=0 ; i < data.m_nNumber ; i ++){
      printf("%d:%s\n",i,data.m_stRteGroup[i].m_fnStr(szError2,sizeof(szError2)-1));
   }

   ModRoute();
   SipNodeLocal_t  stICLocal;
   SipNodeRemote_t stICRemote;
   SipRoute_t      stICRoute;

   SipNodeLocal_t  stOGLocal;
   SipNodeRemote_t stOGRemote;
   SipRoute_t      stOGRoute;

   strcpy(stICLocal.m_szIP,"10.0.99.15");
   stICLocal.m_usPort=5050;
   stICLocal.m_ucProto=E_ESIP_TRANSPORT_TLS_TCP;

   strcpy(stICRemote.m_szIP,"10.0.99.107");
   stICRemote.m_usPort=15081;
   stICRemote.m_ucProto=E_ESIP_TRANSPORT_UDP;


   for( int i=0 ; i < 10 ; i++){
      SLOG(E_ESipRteLogLevel_DEB,"START-----------%d",i);
      nRet=IfESipRteApi_GetTargetBySpecialRouteSeq(
               19501,&stICLocal,&stICRemote,&stOGLocal,&stOGRemote,
               szError, &stICRoute,&stOGRoute);
      if(nRet != 0 ){
         GetStringSipRteErr(nRet,szError2,sizeof(szError2)-1);
         printf("Error1: %s \n",szError);
         printf("Error2: %s \n",szError2);
      }else{
         printf("*RTE:%s\n",stOGRoute.m_fnStr(szError2,sizeof(szError2)-1));
      }
      THESIPDBMGR->m_fnPrint(4);

      if( i == 5){
         ModSSeq();
      }
   }
#endif

#if 0

void MakeDir(char* _pszPath)
{
   //dir check
   if( CSipRteUtil::IsDir(_pszPath)){
     return;
   }

   int nLen=0;
   char szBuf[256];szBuf[255]=0x00;
   strncpy(szBuf,g_pstSipRteDir,sizeof(szBuf)-1);
   nLen=strlen(szBuf);
   char szDir[8][128];
   int nRet=0;
   int nCnt=0;
   nRet=CSipRteUtil::StrToken(szBuf,(char*)"/",szDir,nCnt,8);
   if( nCnt == 0 )  return;
   //make dir
   mode_t curMode= umask(0); 
   for(int i=0; i < nCnt && i < 8 ;i++){
      if( szDir[i][0] == 0x00 ) break;
      szBuf[0]=0x00;
      for( int j = 0 ; j <= i && j < nCnt && j < 8 ; j++){
         snprintf(szBuf+strlen(szBuf),sizeof(szBuf)-1,"%s/",szDir[j]);
      }
      if( CSipRteUtil::IsDir(szBuf) ){
         continue;
      }
      //make dir
      nRet=mkdir(szBuf,0777);
      if(nRet!=0) break;
   }
   umask(curMode);
}

#endif

#define FILEMAXLEN_MEMINFO (17580+1024)
static int nFSize=0;
void m_fnGetRealMemInfo2(int* total, int* free)
{
   FILE* pFD=NULL;
   //static const char* st_pFilepath = "/proc/meminfo";
   static const char* st_pFilepath = "./aaa";
   static char* st_pFileBuffer=new char[FILEMAXLEN_MEMINFO];
   static char* st_pFileBuffer2=new char[FILEMAXLEN_MEMINFO];

   //init
   *total=0;
   *free=0;
   //fopen
   if( (pFD=fopen(st_pFilepath,"r"))==NULL ){
      printf("%s ==========================================================> fopen error!!\n",st_pFilepath);
      return;
   }
#if 1
   int nRet=fseek(pFD,0,SEEK_END);
   if( nRet < 0) printf("============FSEEK ERRO\n");
   int nSize=ftell(pFD);
   if( nSize <= 0) printf("============FSIZE ERRO\n");
   fseek(pFD,0,SEEK_SET);

   if( nFSize != nSize ){
      printf("============FSIZE ERRO!!!!!!!!!!!!!\n");
   }
   fread(st_pFileBuffer,1,nSize,pFD);
   if( memcmp(st_pFileBuffer,st_pFileBuffer2,nSize) != 0 ){
      printf("======!!!======FREAD RRO!!!!!!!!!!!!!\n");
   }

   //fread
   memcpy(st_pFileBuffer2,st_pFileBuffer,nSize);

   nFSize=nSize;

   fseek(pFD,0,SEEK_SET);

   //read
   char linebuf[1024];
   int nCnt=0;
   while(fgets(linebuf,1024,pFD) != NULL){
      //printf("%s ",linebuf);
      nCnt++;
   }
   if( nCnt !=  300 ){
          printf("================ FAIL %d\n",nCnt);
   }else{
          //printf("================ SUCC %d\n",nCnt);
   }   
#endif
   fclose(pFD);
}


/**
*total: total memory
*free : Memfree + Buffers + Cached - Shem

***Caution
*total == 0 or *free == 0 is fail.

**/
#define RHEL_MEMINFO_LEN_TOTAL       (9)
#define RHEL_MEMINFO_LEN_FREE        (8)
#define RHEL_MEMINFO_LEN_BUFFERS     (8)
#define RHEL_MEMINFO_LEN_CACHED      (7)
#define RHEL_MEMINFO_LEN_SHMEM       (6)
void m_fnGetMemInfo(int* total, int* free)
{
/*
   [old] Free = Memfree + Buffers + Cached
   [new] Free = Memfree + Buffers + Cached - Shem
*/
   char strKey[256], strValue[256];
   unsigned int nFree = 0,    //MemFree
                nCached = 0,  //Cached
                nBuffers = 0, //Buffers
                nShmem = 0;   //Shmem

   //initialize
   *total=0;
   *free=0;

   FILE *fd = fopen("/proc/meminfo", "r");
   if (fd == NULL) {
      return;
   }

   char strBuff[1024];
   memset(strBuff, 0x00, sizeof(strBuff));
   char* tmpPtr=NULL;
   char* miscPtr[2];
   bool  bFind[5]={false,};
   int nTmpLen=0;

   while (fgets(strBuff, sizeof(strBuff)-1, fd) != NULL) {
      memset(strKey, 0x00, sizeof(strKey));
      memset(strValue, 0x00, sizeof(strValue));

      //the first string token
      tmpPtr=NULL;
      //strtok_r thread safe
      if( (tmpPtr=strtok_r(strBuff," ",&miscPtr[0]) )==NULL ){
         continue;
      }else{
         strncpy(strKey,tmpPtr,sizeof(strKey)-1);
      }
      //the second string token
      tmpPtr=NULL;
      //strtok_r thread safe
      if( (tmpPtr=strtok_r(NULL," ",&miscPtr[0]) )==NULL ){
         continue;
      }else{
         strncpy(strValue,tmpPtr,sizeof(strValue)-1);
         //should be number type. 
         nTmpLen=strlen(strValue);
         //check number type
         bool bIsNumber=true;
         for( int i =0 ; i < nTmpLen ; i ++){
            if( !(strValue[i] >= '0' && strValue[i] <= '9')){
               bIsNumber=false;
               break;
            }
         }
         if( nTmpLen > 0 && bIsNumber == false ) continue;
      }
      if (strncasecmp(strKey, "MemTotal:",RHEL_MEMINFO_LEN_TOTAL) == 0) {
         *total = atoi(strValue);
         bFind[0]=true;
      }else if (strncasecmp(strKey, "MemFree:",RHEL_MEMINFO_LEN_FREE) == 0) {
         nFree = atoi(strValue);
         bFind[1]=true;
      }else if (strncasecmp(strKey, "Buffers:",RHEL_MEMINFO_LEN_BUFFERS) == 0) {
         nBuffers = atoi(strValue);
         bFind[2]=true;
      }else if (strncasecmp(strKey, "Cached:",RHEL_MEMINFO_LEN_CACHED) == 0) {
         nCached = atoi(strValue);
         bFind[3]=true;
      }else if (strncasecmp(strKey, "Shmem:",RHEL_MEMINFO_LEN_SHMEM) == 0) {
         nShmem = atoi(strValue);
         bFind[4]=true;
      }
      //check parsing end...
      if((bFind[0] == true) &&
         (bFind[0] == bFind[1]) && 
         (bFind[1] == bFind[2]) &&
         (bFind[2] == bFind[3]) &&
         (bFind[3] == bFind[4])){
            break;
      }
   }
   //fclose..
   fclose(fd);

   //check parsing result
   if((bFind[0] == true) &&
      (bFind[0] == bFind[1]) && 
      (bFind[1] == bFind[2]) &&
      (bFind[2] == bFind[3])){
      if( nFree > 0 ){
         *free = nFree;
      }
      if ( nBuffers> 0 ){
         *free += nBuffers;
      }
      if ( nCached> 0 ){
         *free += nCached;
      }
   } 

   //check shared mem
   if( bFind[4] == true && nShmem > 0 ){
      *free -= nShmem;
   }
      
   //exception
   if( *free <=0 ) *free=0;
   if( *total <=0 ) *total=0;
   if( *free > *total ) *free=*total;
}
